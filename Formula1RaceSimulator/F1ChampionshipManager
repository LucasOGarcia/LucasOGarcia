/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package coursework;


import java.awt.event.WindowEvent;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Random;
import java.util.Scanner;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextArea;

/**
 *
 * @author lucas
 */
public class F1ChampionshipManager implements ChampionshipManager{
    
    private List<String> teamRecord;
    private List<Integer> teamOccupationTracker;
    private List<Formula1Driver> driverRecord;
    private List<String> raceRecord;
    private List<LocalDate> raceDateRecord;
    private LocalDate currentDate;
    private final int maxNumberOfTeams = 10;
    private final int noDriverInTeam = 0;
    private final int driverInTeam = 1;
    
    private JFrame jFrame;
    private JTextArea windowTextArea;
    private JTextArea tableTextArea;
    private final String defaultTableSortingType = "Descending";
    
    //Constructor
    
    public F1ChampionshipManager(){
        teamRecord = new ArrayList<String>();
        teamOccupationTracker = new ArrayList<Integer>();
        driverRecord = new ArrayList<Formula1Driver>();
        raceRecord = new ArrayList<String>();
        raceDateRecord = new ArrayList<LocalDate>();
        setLocalDate();
    }
    
    // Setters
    
    public void setTeamRecord(List newTeamRecord){
        this.teamRecord = newTeamRecord;
    }
    
    public void setTeamOccupationTracker(List newTeamOccupationTracker){
        this.teamOccupationTracker = newTeamOccupationTracker;
    }
    
    public void setDriverRecord(List newDriverRecord){
        this.driverRecord = newDriverRecord;
    }
    
    public void setRaceRecord(List newRaceRecord){
        this.raceRecord = newRaceRecord;
    }
    
    public void setRaceDateRecord(List newRaceDateRecord){
        this.raceDateRecord = newRaceDateRecord;
    }
    
    public void setCurrentDate(LocalDate newCurrentDate ){
        this.currentDate = newCurrentDate;
    }
    
    public void setJFrame(JFrame newJFrame){
        this.jFrame = newJFrame;
    }
    
    public void setWindowTextArea(JTextArea newWindowTextArea){
        this.windowTextArea = newWindowTextArea;
    }
    
    public void setTableTextArea(JTextArea newTableTextArea){
        this.tableTextArea = newTableTextArea;
    }
    
    // Getters
    
    public List getTeamRecord(){
        return this.teamRecord;
    }
    
    public List getTeamOccupation(){
        return this.teamOccupationTracker;
    }
    
    public List getDriverRecord(){
        return this.driverRecord;
    }
    
    public List getRaceRecord(){
        return this.raceRecord;
    }
    
    public List getRaceDateRecord(){
        return this.raceDateRecord;
    }
    
    public LocalDate getCurrentDate(){
        return this.currentDate;
    }
    
    // Main menu via console
    
    public void f1ChampionshipConsoleMenu(){
        
        Scanner input = new Scanner(System.in); //main menu scanner
        int menuCounter = 1; //counter to loop the main menu
        String menuChoice; // stores option chosen for the main menu 
            
            while (menuCounter == 1)
            {
                System.out.println("\nCD: Create a new driver \nT: Transfer a driver to another team \nD: Delete a driver and his team \nDS: Display an driver's statistics \nAR: Add a race \nFT: Display a f1 driver table \nS: to save data \nL: to load data \nExit: to leave the menu");
                menuChoice = input.nextLine();
                menuChoice = menuChoice.toUpperCase();
                input = new Scanner(System.in);
                
                switch (menuChoice){
                    
            // Create a driver and choose his team
                case "CD":
                    createDriver();
                    break;
            // Tranfer driver to another team        
                case "T":
                    transferDriver();
                    break;
                    
            // Delete a driver and the team he belongs to       
                case "D":
                    deleteDriver();
                    break;  
                    
            // Display a driver's statistics   
                case "DS":
                    displayStatistics();
                    break;
                    
            // Add a race
                case "AR":
                    addRace();
                    break;
                    
            // Display a f1 driver table
                case "FT":
                    f1Table();
                    break;
            // Save data
                case "S":
                    save();
                    break;
            // Load data
                case "L":
                    load();
                    break;   
                    
                case "EXIT":
                    jFrame.dispatchEvent(new WindowEvent(jFrame, WindowEvent.WINDOW_CLOSING));
                    break;
                    
                default:
                    System.out.println("Please enter a valid option \n");
                    break;
            }
        }
    }
    
    // part 1 & 2 -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
    public void createTeam(){
        String newTeam;
        Scanner teamAdd = new Scanner(System.in);
        boolean teamLoopCounter = true;
        printListOfTeams();
        
        while (teamLoopCounter == true){
            // get input on team name
            System.out.println("Please enter a team name \n");
            if (teamAdd.hasNext()){
                String tempTeamNameCheck = teamAdd.nextLine();
                tempTeamNameCheck = tempTeamNameCheck.toLowerCase();
                tempTeamNameCheck = capitalize(tempTeamNameCheck);
                teamAdd = new Scanner(System.in);
                // check if team already exists
                if (checkIfTeamExists(tempTeamNameCheck) == false){
                    newTeam = tempTeamNameCheck;
                    teamRecord.add(newTeam);
                    teamOccupationTracker.add(noDriverInTeam);
                    System.out.println("The team " + newTeam + " has been successfully created!\n");
                    teamLoopCounter = false;
                }
                else{
                    System.out.println("Error! the team already exists/has a driver\n");
                }  
            }
        }
    }
    
    public boolean checkIfTeamExists(String teamName){
        if (teamRecord.isEmpty()){
           return false;
        }
        if (teamRecord.contains(teamName)){
            return true;
        }
        else{
            return false;
        }
    }
    
    public boolean checkForEmptyTeams(){
        // checks if a team already has an driver
        int emptyTeamCounter = 0;
        if (teamOccupationTracker.isEmpty()){
            return false;
        }
        for (int x = 0; x < teamOccupationTracker.size(); x++){
           if (teamOccupationTracker.get(x) == 0){
               emptyTeamCounter++;
           }
        }
        if (emptyTeamCounter >0){
            return true;
        }
        else{
            return false;
        }
    }
    
    public void printListOfTeams(){
        List<String> teamsWithDriver;
        List<String> teamsWithNoDriver;
        teamsWithDriver = new ArrayList<String>();
        teamsWithNoDriver = new ArrayList<String>();
        int emptyTeamCounter = 0;
        int occupiedTeamCounter = 0;
        
        for (int x = 0; x < teamOccupationTracker.size(); x++){
           if (teamOccupationTracker.get(x) == 0){
               teamsWithNoDriver.add(teamRecord.get(x));
               emptyTeamCounter++;
           }
        }
        for (int x = 0; x < teamOccupationTracker.size(); x++){
           if (teamOccupationTracker.get(x) == 1){
               teamsWithDriver.add(teamRecord.get(x));
               occupiedTeamCounter++;
           }
        }
        if (emptyTeamCounter == 0 && occupiedTeamCounter == 0){
            System.out.println("There are currently no teams created\n");
            return;
        }
        if (emptyTeamCounter >0){
            System.out.println("Empty teams:");
            for (int x = 0; x < teamsWithNoDriver.size(); x++){
                if(teamsWithNoDriver.get(x) != null){
                    System.out.println(teamsWithNoDriver.get(x));
                }
            }
            System.out.println("\n");
        }
        if (occupiedTeamCounter >0){
            System.out.println("Occupied teams:");
            for (int x = 0; x < teamsWithDriver.size(); x++){
                if(teamsWithDriver.get(x) != null){
                    System.out.println(teamsWithDriver.get(x));
                }
            }
            System.out.println("\n");
        }
    }
    
    public void printListOFemptyTeams(){
        int emptyTeamCounter = 0;
        for (int x = 0; x < teamOccupationTracker.size(); x++){
           if (teamOccupationTracker.get(x) == 0){
               System.out.println("Team: " + teamRecord.get(x));
               emptyTeamCounter++;
           }
        }
    }

    @Override
    public void createDriver(){
        String driverName;
        String driverTeam;
        String driverLocation;
        Scanner driverAdd = new Scanner(System.in);
        boolean teamNameCounter = true;
        boolean teamChooseCounter = true;
        // check if max team number has been achieved
        if(teamRecord.size() == maxNumberOfTeams){
            System.out.println("Unable to create a new driver since maximum number of teams have been reached!");
            return;
        }
        System.out.println("Please enter the driver's name\n");
        if (driverAdd.hasNext()){
            driverName = driverAdd.nextLine();
            driverName = driverName.toLowerCase();
            driverName = capitalize(driverName);
            driverAdd = new Scanner(System.in);
            
            while (teamNameCounter == true){
                if (checkForEmptyTeams() == false) {
                    System.out.println("Since there are no currently available teams, team creation will start\n");
                    createTeam();
                    teamNameCounter = false;
                }
            }
            // choose the driver's team
            while (teamChooseCounter == true){
                System.out.println("Please choose the driver's team from the following list\n");
                printListOFemptyTeams();
                String tempTeamCheck = driverAdd.nextLine();
                tempTeamCheck = tempTeamCheck.toLowerCase();
                tempTeamCheck = capitalize(tempTeamCheck);
                driverAdd = new Scanner(System.in);
                // check if team is availabe and exists, then adds driver
                if (teamRecord.contains(tempTeamCheck) == true){
                    int indexCounter = teamRecord.indexOf(tempTeamCheck);
                    int driverCounter = teamOccupationTracker.get(indexCounter);
                    if (driverCounter == 0){
                        driverTeam = tempTeamCheck;
                        System.out.println("Please enter the driver's location \n");    
                        if (driverAdd.hasNext()){
                            driverLocation = driverAdd.nextLine();
                            driverAdd = new Scanner(System.in);
                            Formula1Driver driver = new Formula1Driver(driverName, driverTeam, driverLocation);
                            teamOccupationTracker.set(indexCounter, driverInTeam);
                            driverRecord.add(driver);
                            System.out.println("The driver" + " " + driverName + " " + "Has been successfully created and assgined to team" + " " + driverTeam+"!");
                            teamChooseCounter = false;
                        }
                    }
                    else{
                        System.out.println("Error this team already has a driver\n");
                    }
                }
                else{
                System.out.println("Error! please enter a valid team name\n");
                }
            }
        }
    }
    
    @Override
    public void deleteDriver(){
        Scanner driverDelete = new Scanner(System.in);
        boolean driverTeamCounter = true;
        
        if (driverRecord.isEmpty()){
            System.out.println("There are no drivers to delete\n");
            return;
        }
        //finds if the input exists and has a driver
        while (driverTeamCounter == true){
            System.out.println("Type a driver's team name to delete him and his team from the following list:");

            for (int x = 0; x < driverRecord.size(); x++){
                    System.out.println("Name:" + " " + driverRecord.get(x).getDriverName() + ", " + "Team:" + " " + driverRecord.get(x).getDriverTeam() );
            }
            String selectedDriverTeam = driverDelete.nextLine();
            selectedDriverTeam = selectedDriverTeam.toLowerCase();
            selectedDriverTeam = capitalize(selectedDriverTeam);
            driverDelete = new Scanner(System.in);
            //delete the driver and team info from arraylists
            if (teamRecord.contains(selectedDriverTeam) == true){
                for (int x = 0; x < driverRecord.size(); x++){
                    if (driverRecord.get(x).getDriverTeam().equals(selectedDriverTeam)){
                            int index = teamRecord.indexOf(selectedDriverTeam);
                            teamOccupationTracker.remove(index);
                            driverRecord.remove(index);
                            teamRecord.remove(index);
                            System.out.println("The driver and his team have been successfully deleted!");
                            driverTeamCounter = false;
                    }
                }
            }
            else{
                System.out.println("Error no team name matches the input\n");
            }
        }
    }
    
    @Override
    public void transferDriver(){
        Scanner newTeamScan = new Scanner(System.in);
        int newTeamCounter = 0;
        String currentTeamName = null;
        String newTeamName = null;
        Formula1Driver driver = null;
        Formula1Driver driver2 = null;
        
        
        if (driverRecord.size() <2){
            System.out.println("There are not enough drivers to peform a transfer");
            return;
        }
        // get the driver's current team
        while(newTeamCounter == 0){
            System.out.println("Please type the name of the driver's team you wish to transfer from the following list:");
            for (int x = 0; x < driverRecord.size(); x++){
                System.out.println("Name:" + " " + driverRecord.get(x).getDriverName() + ", " + "Team:" + " " + driverRecord.get(x).getDriverTeam() );
            }
            if (newTeamScan.hasNext()){
                currentTeamName = newTeamScan.nextLine();
                currentTeamName = currentTeamName.toLowerCase();
                currentTeamName = capitalize(currentTeamName);
                newTeamScan = new Scanner(System.in);
                if (teamRecord.contains(currentTeamName) == true){
                    for (int x = 0; x < driverRecord.size(); x++){
                        if (driverRecord.get(x).getDriverTeam().equals(currentTeamName) == true){
                            driver = driverRecord.get(x);
                            newTeamCounter = 1;
                            break;
                        }
                    }
                }
                else{
                    System.out.println("Error! please enter a valid team name from the list\n");
                }
            }
        }
        // get the team driver will be transfering to
        newTeamCounter = 0;
        while(newTeamCounter == 0){
            System.out.println("Please type the name of the team you wish to transfer the driver to from the following list:");
            for (int x = 0; x < driverRecord.size(); x++){
                if (driverRecord.get(x).getDriverTeam().equals(currentTeamName) == false){
                    System.out.println("Name:" + " " + driverRecord.get(x).getDriverName() + ", " + "Team:" + " " + driverRecord.get(x).getDriverTeam() );
                }
            }
            newTeamName = newTeamScan.nextLine();
            newTeamName = newTeamName.toLowerCase();
            newTeamName = capitalize(newTeamName);
            newTeamScan = new Scanner(System.in);
            if (teamRecord.contains(newTeamName) == true && !newTeamName.equals(currentTeamName)){
                for (int x = 0; x < driverRecord.size(); x++){
                    if (driverRecord.get(x).getDriverTeam().equals(newTeamName) == true){
                        driver2 = driverRecord.get(x);
                        newTeamCounter = 1;
                        break;
                    }
                }
            }
            else{
                System.out.println("Error! please enter a valid team name from the list\n");
            }
        }
        //asign driver to the new team and delete the old team
        driver2.setDriverName(driver.getDriverName());
        driver2.setDriverLocation(driver.getDriverLocation());
        driver2.setDriverFirstPos(driver.getDriverFirstPos());
        driver2.setDriverSecondPos(driver.getDriverSecondPos());
        driver2.setDriverThirdPos(driver.getDriverThirdPos());
        driver2.setDriverRaces(driver.getDriverRaces());
        for (int x = 0; x < driverRecord.size(); x++){
            if (driverRecord.get(x).getDriverTeam().equals(currentTeamName) == true){
                driverRecord.remove(x);
                teamRecord.remove(x);
                teamOccupationTracker.remove(x);
                break;
            }
        }
        System.out.println("The driver" + driver2.getDriverName() + " " + "Has been succesfully been transfered to the team" + " " + newTeamName);        
    }

    @Override
    public void displayStatistics(){
        Scanner driverStats = new Scanner(System.in);
        boolean driverTeamCounter = true;
        
        if (driverRecord.isEmpty()){
            System.out.println("There are currently no drivers");
            return;
        }
        // if input matches a team name, show statistics for the driver in that team
        while (driverTeamCounter == true){
            System.out.println("Please type the name of the driver's team you would like to see statistics from the following:");
            for ( int x = 0; x < driverRecord.size(); x++){
                System.out.println("Name:" + " " + driverRecord.get(x).getDriverName() + " " + "Team:" + " " + driverRecord.get(x).getDriverTeam());

            }
            String selectedDriverTeam = driverStats.nextLine();
            selectedDriverTeam = selectedDriverTeam.toLowerCase();
            selectedDriverTeam = capitalize(selectedDriverTeam);
            driverStats = new Scanner(System.in);
            if (teamRecord.contains(selectedDriverTeam) == true){
                for(int x = 0; x < driverRecord.size(); x++){
                    if (driverRecord.get(x).getDriverTeam().equals(selectedDriverTeam)){
                        String driverName = driverRecord.get(x).getDriverName();
                        String driverLocation = driverRecord.get(x).getDriverLocation();
                        String driverTeam = driverRecord.get(x).getDriverTeam();
                        int driverPoints = driverRecord.get(x).getDriverPoints();
                        int driverRaces = driverRecord.get(x).getDriverRaces();
                        int driverFirstPos = driverRecord.get(x).getDriverFirstPos();
                        int driverSecondPos = driverRecord.get(x).getDriverSecondPos();
                        int driverThirdPos = driverRecord.get(x).getDriverThirdPos();

                        System.out.println("Name: " + driverName+ "\n" + "Team: " + driverTeam + "\n" +"Location: " + driverLocation +"\n" + "Number of points: " + driverPoints + "\n" + "Number of races: " + driverRaces +"\n" + "Number of 1st place: " + driverFirstPos + "\n" + "Number of 2nd place: " + driverSecondPos + "\n" + "Number of 3rd place: " + driverThirdPos );
                        driverTeamCounter = false;
                    }
                }
            }
            else{
                System.out.println("Error no teams match the input\n");
            }
        }
    }
       
    @Override
    public void addRace(){
        List<Integer> racePos;
        List<Formula1Driver> driverRecordCopy;
        racePos = new ArrayList<Integer>();
        driverRecordCopy = new ArrayList<Formula1Driver>();
        
        if (driverRecord.isEmpty()){
            System.out.println("There are currently no drivers to hold a race");
            return;
        }
        // add positions to arraylist and reference to driver objects to arraylist
        for (int x = 0; x < driverRecord.size(); x++){
            racePos.add(x+1);
            driverRecordCopy.add(driverRecord.get(x));
        }
        // Give a driver a randomPosition within the race
        for (int x = 0; x < driverRecord.size(); x++){
            Random rand = new Random();
            Integer randomPosNum = racePos.get(rand.nextInt(racePos.size()));
            Formula1Driver randomDriver = driverRecordCopy.get(rand.nextInt(driverRecordCopy.size()));
            randomDriver.setDriverTempPosition(randomPosNum);
            racePos.remove(randomPosNum);
            driverRecordCopy.remove(randomDriver);          
        }
        assignRacePoints();
        f1Table();
    }
    
    public void assignRacePoints(){
        // distribute points based on the position the driver achieved
        List<Formula1Driver> driverRecordCopy = new ArrayList();
        //get date of the race
        String race = "\nRace date: " + currentDate.toString();
        int firstPos = 25;
        int secondPos = 18;
        int thirdPos = 15;
        int fourthPos = 12;
        int fithPos = 10;
        int sixthPos = 8;
        int seventhPos = 6;
        int eighthPos = 4;
        int ninthPos = 2;
        int tenthPos = 1;
        int notInTopTen = 0;
        for(int x = 0; x < driverRecord.size(); x++){
            Formula1Driver driver = driverRecord.get(x);
            int driverPos = driver.getDriverTempPosition();
            switch (driverPos){
                case 1:
                    driver.addDriverPoints(firstPos);
                    driver.addDriverFirstPos();
                    break;
                case 2:
                    driver.addDriverPoints(secondPos);
                    driver.addDriverSecondPos();
                    break;
                case 3:
                    driver.addDriverPoints(thirdPos);
                    driver.addDriverThirdPos();
                    break;
                case 4:
                    driver.addDriverPoints(fourthPos);
                    break;
                case 5:
                    driver.addDriverPoints(fithPos);
                    break;
                case 6:
                    driver.addDriverPoints(sixthPos);
                    break;
                case 7:
                    driver.addDriverPoints(seventhPos);
                    break;
                case 8:
                    driver.addDriverPoints(eighthPos);
                    break;
                case 9:
                    driver.addDriverPoints(ninthPos);
                    break;
                case 10:
                    driver.addDriverPoints(tenthPos);
                    break;
                default:
                    driver.addDriverPoints(notInTopTen);
                    break;
            }
        }
        // copy all drivers into a separate list
        for (int x = 0; x < driverRecord.size(); x++){
            driverRecordCopy.add(driverRecord.get(x));
        }
        // sort drivers by the position they achieved in the race
        Collections.sort(driverRecordCopy, new Comparator<Formula1Driver>(){
            @Override
            public int compare(Formula1Driver driver1, Formula1Driver driver2){
                Integer driver2RacePos = driver2.getDriverTempPosition();
                Integer driver1RacePos = driver1.getDriverTempPosition();
                return driver1RacePos.compareTo(driver2RacePos);
            }
        });
        // update race object with each driver's position
        for (int x = 0; x < driverRecordCopy.size(); x++){
            Formula1Driver driver = driverRecordCopy.get(x);
            race = updateRaceObject(race, driver);
            driver.addDriverRaces();
        }
        //Reset the drivers postion to test value of 0
        System.out.println(race);
        raceRecord.add(race);
        for(int x = 0; x < driverRecord.size(); x++){
            int resetPos = 0;
            driverRecord.get(x).setDriverTempPosition(resetPos);
        }
        //Reset the driver startingposition to test value of 0
        for(int x = 0; x < driverRecord.size(); x++){
            int resetPos = 0;
            driverRecord.get(x).setDriverTempStartPosition(resetPos);
        }
        // add one day to current date
        raceDateRecord.add(currentDate);
        incrementOneDay();
    }
    
    public String updateRaceObject(String race, Formula1Driver driver){
        //update the string object that keeps track of race info
        String tempRace = race;
        race = tempRace + "\n" + driver.getDriverName() + " " + driver.getDriverTeam() + " " + "Race position: " + driver.getDriverTempPosition();
        return race;
    }
    
    @Override
    public void f1Table(){
        //show the table by descending order of points
        List<Formula1Driver> driverRecordCopy;
        driverRecordCopy = new ArrayList<Formula1Driver>();
        
        if (driverRecord.isEmpty()){
            System.out.println("There are currently no drivers to display a table");
            return;
        }
        if (raceRecord.isEmpty()){
            System.out.println("There are currently no races to display a table");
            return;
        }
        for (int x = 0; x < driverRecord.size(); x++){
            driverRecordCopy.add(driverRecord.get(x));
        }
        Collections.sort(driverRecordCopy, new Comparator<Formula1Driver>(){
            @Override
            public int compare(Formula1Driver driver1, Formula1Driver driver2) {
                // compare two instances of drivers based on their points.
                
                Integer driver2Points = driver2.getDriverPoints();
                Integer driver1Points = driver1.getDriverPoints();
                return driver2Points.compareTo(driver1Points);
            }
        });
        if (driverRecord.size() > 1){
            if (driverRecordCopy.get(0).getDriverPoints() == driverRecordCopy.get(1).getDriverPoints() && driverRecordCopy.get(1).getDriverFirstPos() > driverRecordCopy.get(0).getDriverFirstPos()){
                Collections.swap(driverRecordCopy, 0, 1);
            }
        }
        System.out.println("\nTournament table:\n");
        for (int x = 0; x < driverRecordCopy.size(); x++){
            System.out.println(driverRecordCopy.get(x).getDriverTeam() + " " + driverRecordCopy.get(x).getDriverName() + " points " +driverRecordCopy.get(x).getDriverPoints() + " No.First places: " + driverRecordCopy.get(x).getDriverFirstPos() + "  No.Second places: " + driverRecordCopy.get(x).getDriverSecondPos() + "  No.Thrid places: " + driverRecordCopy.get(x).getDriverThirdPos());
        }
    }
    
    public void save(){
        // saves the info stored in this F1ChampionshipManager object
        try{
            FileOutputStream fileStream = new FileOutputStream("save.dat");
            BufferedOutputStream bufferStream = new BufferedOutputStream(fileStream);
            ObjectOutputStream objectStream = new ObjectOutputStream(bufferStream);

            DataSaver saveData = new DataSaver();
            F1ChampionshipManager f1Championship = new F1ChampionshipManager();
            f1Championship.setTeamRecord(this.teamRecord);
            f1Championship.setTeamOccupationTracker(this.teamOccupationTracker);
            f1Championship.setDriverRecord(this.driverRecord);
            f1Championship.setRaceRecord(this.raceRecord);
            f1Championship.setRaceDateRecord(this.raceDateRecord);
            f1Championship.setCurrentDate(this.currentDate);
            saveData.save(f1Championship);
            objectStream.writeObject(saveData);
            objectStream.close();
            System.out.println("Data has been sucesfully saved!");
        }
        catch(IOException exception){
            exception.printStackTrace();
        }
    }
    
    public void load(){
        //loads data into this F1ChampionshipManager object
        DataSaver loadData;
        loadData = new DataSaver();
        try{
            FileInputStream fileStream = new FileInputStream("save.dat");
            BufferedInputStream bufferStream = new BufferedInputStream(fileStream);
            ObjectInputStream objectStream = new ObjectInputStream(bufferStream);

            loadData = (DataSaver)objectStream.readObject();
            objectStream.close();
        }
        catch(IOException exception){
//            exception.printStackTrace();
            System.out.println("No data to load from was found...");
            return;
        }
        catch(ClassNotFoundException exception){
//            exception.printStackTrace();
            return;
        }
        
        this.teamRecord = loadData.getTeamRecord();
        this.teamOccupationTracker = loadData.getTeamOccupation();
        this.driverRecord = loadData.getDriverRecord();
        this.raceRecord = loadData.getRaceRecord();
        this.raceDateRecord = loadData.getRaceDateRecord();
        this.currentDate = loadData.getCurrentDate();
        f1Table();
        System.out.println("Data has been sucesfully loaded!");
    }
    
    public String capitalize(String string) {
        if(string == null || string.isEmpty()) {
            return string;
        }
        return string.substring(0, 1).toUpperCase() + string.substring(1);
    }
    
    
    public void setLocalDate(){
        LocalDate date = LocalDate.now();
        this.currentDate = date;
    }
    
    public void incrementOneDay(){
        this.currentDate = currentDate.plusDays(1);
    }

    // Part 3 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
       
    public void addRacePart3(){
        List<Integer> racePos;
        List<Formula1Driver> driverRecordCopy;
        racePos = new ArrayList<Integer>();
        driverRecordCopy = new ArrayList<Formula1Driver>();
        
        if (driverRecord.isEmpty()){
            windowTextArea.setText("There are currently no drivers to hold a race");
            return;
        }
        // add positions to arraylist and reference to driver objects to arraylist
        for (int x = 0; x < driverRecord.size(); x++){
            racePos.add(x+1);
            driverRecordCopy.add(driverRecord.get(x));
        }
        // Give a driver a randomPosition within the race
        for (int x = 0; x < driverRecord.size(); x++){
            Random rand = new Random();
            Integer randomPosNum = racePos.get(rand.nextInt(racePos.size()));
            Formula1Driver randomDriver = driverRecordCopy.get(rand.nextInt(driverRecordCopy.size()));
            randomDriver.setDriverTempPosition(randomPosNum);
            racePos.remove(randomPosNum);
            driverRecordCopy.remove(randomDriver);          
        }
        windowTextArea.setText("Race results:");
        assignRacePointsPart3();
        f1TableByPoints(defaultTableSortingType);
    }
    
    public void addRaceWithProbability(){
        List<Integer> racePos;
        List<Integer> startingRacePos;
        List<Formula1Driver> driverRecordCopy;
        List<Formula1Driver> driverRecordCopyFinal;
        racePos = new ArrayList<Integer>();
        startingRacePos = new ArrayList<Integer>();
        driverRecordCopy = new ArrayList<Formula1Driver>();
        driverRecordCopyFinal = new ArrayList<Formula1Driver>();
        boolean getWinnerCounter = true;
        
        if (driverRecord.isEmpty()){
            windowTextArea.setText("There are currently no drivers to hold a race");
            return;
        }
        // add positions to arraylist and reference to driver objects to arraylist
        for (int x = 0; x < driverRecord.size(); x++){
            racePos.add(x+1);
            startingRacePos.add(x+1);
            driverRecordCopy.add(driverRecord.get(x));
            driverRecordCopyFinal.add(driverRecord.get(x));
        }
        // Give a driver a random starting Position within the race
        for (int x = 0; x < driverRecord.size(); x++){
            Random rand = new Random();
            Integer randomStartingPosNum = startingRacePos.get(rand.nextInt(startingRacePos.size()));
            Formula1Driver randomDriver = driverRecordCopy.get(rand.nextInt(driverRecordCopy.size()));
            randomDriver.setDriverTempStartPosition(randomStartingPosNum);
            startingRacePos.remove(randomStartingPosNum);
            driverRecordCopy.remove(randomDriver);
        }
        //sort the driver's based on their starting position
        Collections.sort(driverRecordCopyFinal, new Comparator<Formula1Driver>(){
            @Override
            public int compare(Formula1Driver driver1, Formula1Driver driver2){
                Integer driver2StartingRacePos = driver2.getDriverTempStartPosition();
                Integer driver1StartingRacePos = driver1.getDriverTempStartPosition();
                return driver1StartingRacePos.compareTo(driver2StartingRacePos);
            }
        });
        // assign first place to a driver
        while (getWinnerCounter == true){
            for (int x = 0; x < driverRecordCopyFinal.size(); x++){
                if (generateWinner(driverRecordCopyFinal.get(x)) == true){
                    // remove winning driver from the race simulation pool and first place from placement simulation pool
                    driverRecordCopyFinal.get(x).setDriverTempPosition(racePos.get(0));
                    racePos.remove(0);
                    Formula1Driver winningDriver = driverRecordCopyFinal.get(x);
                    driverRecordCopyFinal.remove(winningDriver);
                    getWinnerCounter = false;
                    break;
                }
            }
        }
        // Give a driver a randomPosition within the race
        for (int x = 0; x < driverRecord.size()-1; x++){
            Random rand = new Random();
            Integer randomPosNum = racePos.get(rand.nextInt(racePos.size()));
            Formula1Driver randomDriver = driverRecordCopyFinal.get(rand.nextInt(driverRecordCopyFinal.size()));
            randomDriver.setDriverTempPosition(randomPosNum);
            racePos.remove(randomPosNum);
            driverRecordCopyFinal.remove(randomDriver);          
        }
        windowTextArea.setText("Race results:");
        assignRacePointsPart3();
        f1TableByPoints(defaultTableSortingType);
    }
    
    public void assignRacePointsPart3(){
        // make race string be initiliased with date, and at the end of a race increase date by 1
        List<Formula1Driver> driverRecordCopy = new ArrayList();
        String race = "\nRace date : " + currentDate.toString();
        int firstPos = 25;
        int secondPos = 18;
        int thirdPos = 15;
        int fourthPos = 12;
        int fithPos = 10;
        int sixthPos = 8;
        int seventhPos = 6;
        int eighthPos = 4;
        int ninthPos = 2;
        int tenthPos = 1;
        int notInTopTen = 0;
        for(int x = 0; x < driverRecord.size(); x++){
            Formula1Driver driver = driverRecord.get(x);
            int driverPos = driver.getDriverTempPosition();
            switch (driverPos){
                case 1:
                    driver.addDriverPoints(firstPos);
                    driver.addDriverFirstPos();
                    break;
                case 2:
                    driver.addDriverPoints(secondPos);
                    driver.addDriverSecondPos();
                    break;
                case 3:
                    driver.addDriverPoints(thirdPos);
                    driver.addDriverThirdPos();
                    break;
                case 4:
                    driver.addDriverPoints(fourthPos);
                    break;
                case 5:
                    driver.addDriverPoints(fithPos);
                    break;
                case 6:
                    driver.addDriverPoints(sixthPos);
                    break;
                case 7:
                    driver.addDriverPoints(seventhPos);
                    break;
                case 8:
                    driver.addDriverPoints(eighthPos);
                    break;
                case 9:
                    driver.addDriverPoints(ninthPos);
                    break;
                case 10:
                    driver.addDriverPoints(tenthPos);
                    break;
                default:
                    driver.addDriverPoints(notInTopTen);
                    break;
            }
        }
        // copy all drivers into a separate list
        for (int x = 0; x < driverRecord.size(); x++){
            driverRecordCopy.add(driverRecord.get(x));
        }
        // sort drivers by the position achieved in the race
        Collections.sort(driverRecordCopy, new Comparator<Formula1Driver>(){
            @Override
            public int compare(Formula1Driver driver1, Formula1Driver driver2){
                Integer driver2RacePos = driver2.getDriverTempPosition();
                Integer driver1RacePos = driver1.getDriverTempPosition();
                return driver1RacePos.compareTo(driver2RacePos);
            }
        });
        // update race object with each driver's position
        for (int x = 0; x < driverRecordCopy.size(); x++){
            Formula1Driver driver = driverRecordCopy.get(x);
            race = updateRaceObjectPart3(race, driver);
            driver.addDriverRaces();
        }
        //Reset the drivers postion to test value of 0
        windowTextArea.append(race);
        raceRecord.add(race);
        for(int x = 0; x < driverRecord.size(); x++){
            int resetPos = 0;
            driverRecord.get(x).setDriverTempPosition(resetPos);
        }
        for(int x = 0; x < driverRecord.size(); x++){
            int resetPos = 0;
            driverRecord.get(x).setDriverTempStartPosition(resetPos);
        }
        // add one day to current date
        raceDateRecord.add(currentDate);
        incrementOneDay();
    }
    
    public String updateRaceObjectPart3(String race, Formula1Driver driver){
        String tempRace = race;
        // updates the race object based if the driver had a starting position on the race or not
        if (driver.getDriverTempStartPosition() >0){
            race = tempRace + "\n" + driver.getDriverName() + " | " + driver.getDriverTeam() + " | " + "Race position: " + driver.getDriverTempPosition() + " | " + "Starting position: " + driver.getDriverTempStartPosition();
        }
        else{
            race = tempRace + "\n" + driver.getDriverName() + " | " + driver.getDriverTeam() + " | " + "Race position: " + driver.getDriverTempPosition();
        }
        return race;
    }
    
    public boolean generateWinner(Formula1Driver driver){
        // generates a number based on the driver's starting position
        boolean result = false;
        int winChance = 0;
        switch (driver.getDriverTempStartPosition()){
            case 1:
                winChance = 40;
                result = checkIfDriverWon(winChance);
                break;
            case 2:
                winChance = 30;
                result = checkIfDriverWon(winChance);
                break;
            case 3:
            case 4:
                winChance = 10;
                result = checkIfDriverWon(winChance);
                break;
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
                winChance = 2;
                result = checkIfDriverWon(winChance);
                break;
            default:
                result = false;
        }
        return result;
    }
    
    public boolean checkIfDriverWon(int winChance){
        // generates a winner based on their winning chance
        Random rand = new Random();
        int maxNum = 100;
        int minNum = 1;
        int chanceNum = rand.nextInt(maxNum - minNum + 1) + minNum;
        if (chanceNum <=  winChance){
            return true;
        }
        else{
            return false;
        }
    }
    
    public void seeAllRaces(){
        // show all races that happened in the tournament so far
        windowTextArea.setText("RaceRecord");
        List<LocalDate> raceDateRecordCopy;
        raceDateRecordCopy = new ArrayList<LocalDate>();
        
        if (raceDateRecord.isEmpty()){
            windowTextArea.setText("There are no race records");
            return;
        }
        for (int x = 0; x < raceDateRecord.size(); x++){
            raceDateRecordCopy.add(raceDateRecord.get(x));
        }
        Collections.sort(raceDateRecordCopy, new Comparator<LocalDate>(){
            @Override
            public int compare(LocalDate localDate1, LocalDate localDate2){
                return localDate1.compareTo(localDate2);
            }
        });
        for (int x = 0; x < raceDateRecordCopy.size(); x++){
            windowTextArea.append("\n" + "Race "+ x +": "+ raceDateRecordCopy.get(x).toString());
        }
    }
    
    public void showDriverRaces(){
        //shows a driver's specific race details
        List<String> raceRecordCopy;
        raceRecordCopy = new ArrayList<String>();
        List<LocalDate> raceDateRecordCopy;
        raceDateRecordCopy = new ArrayList<LocalDate>();
        Formula1Driver driver = null;
        int racesParticipated = 0;
        boolean driverTeamCounter = true;
        boolean driverRaceCounter = true;
        
        if (driverRecord.isEmpty()){
            windowTextArea.setText("There are currently no drivers to check race records for");
            return;
        }
        
        //get the driver's team
        windowTextArea.setText(null);
        while (driverTeamCounter == true){
            windowTextArea.append("Type a driver's team name to see his race record from the following list:");
            for (int x = 0; x < driverRecord.size(); x++){
                    windowTextArea.append("\nName:" + " " + driverRecord.get(x).getDriverName() + ", " + "Team:" + " " + driverRecord.get(x).getDriverTeam() );
            }
            JOptionPane jOption = createOptionPane();          
            String selectedDriverTeam = jOption.showInputDialog("Please enter the driver's team name \n");
            if (selectedDriverTeam == null){
                windowTextArea.setText("Driver race record exited.");
                return;
            }
            else if(selectedDriverTeam.length() > 0){
                selectedDriverTeam = selectedDriverTeam.toLowerCase();
                selectedDriverTeam = capitalize(selectedDriverTeam);
                if (teamRecord.contains(selectedDriverTeam) == true){
                    for (int x = 0; x < driverRecord.size(); x++){
                        if (driverRecord.get(x).getDriverTeam().equals(selectedDriverTeam)){
                            driver = driverRecord.get(x);
                            driverTeamCounter = false;
                        }
                    }
                }
                else{
                    windowTextArea.setText("Error! No team name matches the input\n");
                }
            }
            else{
                windowTextArea.setText("Error! Please enter the driver's team name\n");
            }
        }
        for (int x = 0; x < raceRecord.size(); x++){
            if (raceRecord.get(x).contains(driver.getDriverName()) && raceRecord.get(x).contains(driver.getDriverTeam())){
                raceRecordCopy.add(raceRecord.get(x));
                raceDateRecordCopy.add(raceDateRecord.get(x));
                racesParticipated++;
            }
        }
        // check if driver participated in any races
        if (racesParticipated == 0){
            windowTextArea.setText("The driver has not participated in any races");
            return;
        }
        Collections.sort(raceDateRecordCopy, new Comparator<LocalDate>(){
            @Override
            public int compare(LocalDate localDate1, LocalDate localDate2){
                int result = localDate1.compareTo(localDate2);
                int index1 = raceDateRecordCopy.indexOf(localDate1);
                int index2 = raceDateRecordCopy.indexOf(localDate2);
                if (result == -1){
                        Collections.swap(raceRecordCopy, index1, index2);
                }
                return result;
            }
        });
        for (int x = 0; x < raceDateRecordCopy.size(); x++){
        }
        // ask user to input the race number they wish to view info for
        windowTextArea.setText(null);
        while (driverRaceCounter == true){
            windowTextArea.append("Please type the number of the race you wish to view records for from the following: ");
            for(int x = 0; x < raceRecordCopy.size(); x++){
                int y = x+1;
                windowTextArea.append("\nRace " + y + ": " + raceDateRecordCopy.get(x));
            }
            JOptionPane jOption = createOptionPane();          
            String raceNumString = jOption.showInputDialog("Please enter the number of the race you wish to view details about \n");
            if (raceNumString == null){
                windowTextArea.setText("View driver race exited");
                return;
            }
                if (raceNumString.length() >0){
                int raceNum = 0;
                try{
                    raceNum = Integer.parseInt(raceNumString);
                }
                catch(NumberFormatException e){
                    windowTextArea.setText("Error. Please enter a integer \n");
                }
                if (raceNum >=1 && raceNum <= raceDateRecordCopy.size()){
                    windowTextArea.setText(raceDateRecordCopy.get(raceNum-1).toString());
                    windowTextArea.append("\n"+raceRecordCopy.get(raceNum-1));
                    driverRaceCounter = false;
                }
                else{
                    windowTextArea.setText("Error. Please enter a valid race number\n");
                }
            }
            else{
                  windowTextArea.setText("Error. Please enter a race number!");  
                }
        }
    }
    
    public void f1TableByPoints(String sortingType){
        // shows a table depending on a sorting type
        List<Formula1Driver> driverRecordCopy;
        driverRecordCopy = new ArrayList<Formula1Driver>();
        tableTextArea.setText(null);
        if (raceRecord.isEmpty()){
            windowTextArea.append("\nThere are currently no races to display a table");
            return;
        }
        if (driverRecord.isEmpty()){
            tableTextArea.setText(null);
            windowTextArea.setText("There are currently no drivers to display a table");
            return;
        }
        for (int x = 0; x < driverRecord.size(); x++){
            driverRecordCopy.add(driverRecord.get(x));
        }
        switch (sortingType){
            case "Descending":
                sortTableByPointsDescending(driverRecordCopy);
                break;
            case "Ascending":
                SortTableByPointsAscending(driverRecordCopy);
                break;
                
            case "RacePos":
                SortTableByRacePos(driverRecordCopy);
                break;
        }
    }
    
    public void sortTableByPointsDescending(List<Formula1Driver> drivers){
        // sorts driver in desceding order of points
        Collections.sort(drivers, new Comparator<Formula1Driver>(){
            @Override
            public int compare(Formula1Driver driver1, Formula1Driver driver2) {
                // compare two instances of drivers based on their points.
                
                Integer driver2Points = driver2.getDriverPoints();
                Integer driver1Points = driver1.getDriverPoints();
                return driver2Points.compareTo(driver1Points);
            }
        });
        if (driverRecord.size() > 1){
            if (drivers.get(0).getDriverPoints() == drivers.get(1).getDriverPoints() && drivers.get(1).getDriverFirstPos() > drivers.get(0).getDriverFirstPos()){
                Collections.swap(drivers, 0, 1);
            }
        }
        tableTextArea.setText("Tournament table by points (descending):\n");
        for (int x = 0; x < drivers.size(); x++){
            tableTextArea.append("\n"+drivers.get(x).getDriverTeam() + "  |  " + drivers.get(x).getDriverName() + " |  points " +drivers.get(x).getDriverPoints() + " |  No.First places: " + drivers.get(x).getDriverFirstPos() + " |   No.Second places: " + drivers.get(x).getDriverSecondPos() + "  |  No.Third places: " + drivers.get(x).getDriverThirdPos());
        }
    }
    
    public void SortTableByPointsAscending(List<Formula1Driver> drivers){
        // sorts driver in ascending order of points
        Collections.sort(drivers, new Comparator<Formula1Driver>(){
            @Override
            public int compare(Formula1Driver driver1, Formula1Driver driver2) {
                // compare two instances of drivers based on their points.
                
                Integer driver2Points = driver2.getDriverPoints();
                Integer driver1Points = driver1.getDriverPoints();
                return driver1Points.compareTo(driver2Points);
            }
        });
        if (driverRecord.size() > 1){
            if (drivers.get(0).getDriverPoints() == drivers.get(1).getDriverPoints() && drivers.get(1).getDriverFirstPos() > drivers.get(0).getDriverFirstPos()){
                Collections.swap(drivers, 0, 1);
            }
        }
        tableTextArea.setText("Tournament table by points (ascending):\n");
        for (int x = 0; x < drivers.size(); x++){
            tableTextArea.append("\n"+drivers.get(x).getDriverTeam() + "  |  " + drivers.get(x).getDriverName() + " |  points " +drivers.get(x).getDriverPoints() + " |  No.First places: " + drivers.get(x).getDriverFirstPos() + " |   No.Second places: " + drivers.get(x).getDriverSecondPos() + "  |  No.Third places: " + drivers.get(x).getDriverThirdPos());
        }
    }
    
    public void SortTableByRacePos(List<Formula1Driver> drivers){
        // sorts driver by number of first places
        Collections.sort(drivers, new Comparator<Formula1Driver>(){
            @Override
            public int compare(Formula1Driver driver1, Formula1Driver driver2) {
                // compare two instances of drivers based on their race positions.
                
                Integer driver2FirstPos = driver2.getDriverFirstPos();
                Integer driver1FirstPos = driver1.getDriverFirstPos();
                return driver2FirstPos.compareTo(driver1FirstPos);
            }
        });
        if (driverRecord.size() > 1){
            if (drivers.get(0).getDriverFirstPos() == drivers.get(1).getDriverFirstPos() && drivers.get(1).getDriverFirstPos() > drivers.get(0).getDriverFirstPos()){
                Collections.swap(drivers, 0, 1);
            }
        }
        tableTextArea.setText("Tournament table by no. of first postions:\n");
        for (int x = 0; x < drivers.size(); x++){
            tableTextArea.append("\n"+drivers.get(x).getDriverTeam() + "  |  " + drivers.get(x).getDriverName() + " |  points " +drivers.get(x).getDriverPoints() + " |  No.First places: " + drivers.get(x).getDriverFirstPos() + " |   No.Second places: " + drivers.get(x).getDriverSecondPos() + "  |  No.Third places: " + drivers.get(x).getDriverThirdPos());
        }
    }
    
    public JOptionPane createOptionPane(){
        // creates a option pane to get user input in the GUI
        JOptionPane optionPane = new JOptionPane();
        return optionPane;
    }
}
